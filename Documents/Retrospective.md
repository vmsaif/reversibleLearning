# Retrospective

<p> We noticed a significant improvement moving from iteration 1 into iteration 2. In iteration 2 we changed the way we wrote tests, to avoid accidentally breaking tests with code updates close to the deadline. This also creates a window into the other major problem we had in iteration 1 and even in iteration 2; Deadlines. Even in iteration 2, we still ran into the problem of waiting a long time to commit our changes to the master branch. This is because our fixation in iterations 1 and 2 was the final deadline; the project due date. Naturally, this leads to problems if we need to code in tandem with our fellow team members, as we can’t know what the code we’re writing against will look like, or even which features will be in the final release, until very late in the development cycle. With this in mind, we will focus on two different aspects for this retrospective.

<p> We first focus on splitting up the timeline in iteration 3 into manageable chunks, depending on what other aspects of iteration 3 rely on them. This way we know for sure what we will have done when we hit these dates, and can code on top of a base we know exists, on features we know will be finished. This will prevent procrastinating until the iteration’s final days, and we will know what errors and difficulties we have in the code, and can spend more time ensuring that the features we will have in place are up to our standards.

<p> We will also focus on intelligently splitting up work across our team. In iteration one, we split up into teams of 2 and each took a feature to work on. In iteration 2, we just asked who wanted to do what, and we went from there. In iteration 3, we are splitting up work based on who has already worked on the code in that layer before, and we are making the distribution of work more central, assigning one person to create many (if not all) of our initial project issues on gitlab. This will help us keep iteration 3 more organized, and that will help us keep confusion to a minimum, and comfort to a maximum, which will keep iteration 3 running smoothly.

<p> We will measure our success in iteration 3, by looking at our repository graph. There we will be able to keep track of merges on our master branch, which is how we will be finishing our features, tests, etc. If we notice fewer 5 day or more gaps in our merges, we will know that we are keeping a more steady pace for completing features, instead of waiting too long to have a healthy pace for iteration 3. This will also show us if we are keeping work divided more intelligently. By checking the graph, we can check if we are still coding away in relative isolation, or if we are properly committing and merging our branches, and as a result keeping our team members informed of the work we are doing and completing.
